
[match:interface]
M1: """interface Message {
	       jsonrpc: string;
       }"""
M2: """interface RequestMessage extends Message {
            id: integer | string;
            method: string;
            params?: array | object;
        }"""
M3: """interface ProgressParams<T> {
            token: ProgressToken;
            value: T;
        }"""

M4: """export interface WorkspaceEdit {
        changes?: { [uri: DocumentUri]: TextEdit[]; };

        documentChanges?: (
            TextDocumentEdit[] |
            (TextDocumentEdit | CreateFile | RenameFile | DeleteFile)[]
        );

        changeAnnotations?: {
            [id: string /* ChangeAnnotationIdentifier */]: ChangeAnnotation;
        };
    }"""

M5: """export interface ParameterInformation {
        label: string | [uinteger, uinteger];
        documentation?: string | MarkupContent;
    }"""
M6: """interface Color {
        readonly red: decimal;
        readonly green: decimal;
        readonly blue: decimal;
        readonly alpha: decimal;
    }"""
M7: """export interface SemanticTokensRegistrationOptions extends
        TextDocumentRegistrationOptions, SemanticTokensOptions,
        StaticRegistrationOptions {
    }"""
M8: """interface InitializeParams extends WorkDoneProgressParams {
		processId: integer | null;
		clientInfo?: {
			name: string;
			version?: string;
		};
		locale?: string;
		rootPath?: string | null;
		rootUri: DocumentUri | null;
		initializationOptions?: any;
		capabilities: ClientCapabilities;
		trace?: TraceValue;
		workspaceFolders?: WorkspaceFolder[] | null;
    }"""
M9: """interface SemanticTokensClientCapabilities {
		dynamicRegistration?: boolean;
		requests: {
			range?: boolean | {
			};
			full?: boolean | {
				delta?: boolean;
			};
		};
		tokenTypes: string[];
		tokenModifiers: string[];
		formats: TokenFormat[];
		overlappingTokenSupport?: boolean;
		multilineTokenSupport?: boolean;
    }"""
M10: """interface InitializeParams extends WorkDoneProgressParams {
		processId: integer | null;
		clientInfo?: {
			name: string;
			version?: string;
		};
		locale?: string;
		rootPath?: string | null;
		rootUri: DocumentUri | null;
		initializationOptions?: any;
		capabilities: ClientCapabilities;

		trace?: TraceValue;
		workspaceFolders?: WorkspaceFolder[] | null;
    }"""
M11: """interface DidChangeConfigurationParams {
			settings: any;
		}"""
M12: """export interface CodeAction {
		title: string;
		kind?: CodeActionKind;
		diagnostics?: Diagnostic[];
		isPreferred?: boolean;
		disabled?: {
			reason: string;
		};
		edit?: WorkspaceEdit;
		command?: Command;
		data?: any;
	}"""
M13: """export interface TextDocument {
		readonly uri: Uri;
		readonly fileName: string;
		readonly isUntitled: boolean;
		readonly languageId: string;
		readonly version: number;
		readonly isDirty: boolean;
		readonly isClosed: boolean;
		save(): Thenable<boolean>;
		readonly eol: EndOfLine;
		readonly lineCount: number;
		lineAt(line: number): TextLine;
		lineAt(position: Position): TextLine;
		offsetAt(position: Position): number;
		positionAt(offset: number): Position;
		getText(range?: Range): string;
		getWordRangeAtPosition(position: Position, regex?: RegExp): Range | undefined;
		validateRange(range: Range): Range;
		validatePosition(position: Position): Position;
	}"""
M14: """export interface Event<T> {
			(listener: (e: T) => any, thisArgs?: any, disposables?: Disposable[]): Disposable;
		}"""
M15: """export interface CustomEditorProvider<T extends CustomDocument = CustomDocument> extends CustomReadonlyEditorProvider<T> {
		readonly onDidChangeCustomDocument: Event<CustomDocumentEditEvent<T>> | Event<CustomDocumentContentChangeEvent<T>>;
		saveCustomDocument(document: T, cancellation: CancellationToken): Thenable<void>;
		saveCustomDocumentAs(document: T, destination: Uri, cancellation: CancellationToken): Thenable<void>;
		revertCustomDocument(document: T, cancellation: CancellationToken): Thenable<void>;
		backupCustomDocument(document: T, context: CustomDocumentBackupContext, cancellation: CancellationToken): Thenable<CustomDocumentBackup>;
	}"""


[py:interface]
M7: """
	class SemanticTokensRegistrationOptions(TextDocumentRegistrationOptions, SemanticTokensOptions, StaticRegistrationOptions):
	    pass
    """
M9: """
	class SemanticTokensClientCapabilities(TypedDict, total=False):
	    class Requests_0(TypedDict, total=False):
	        class Range_1(TypedDict, total=True):
	            pass
	        class Full_1(TypedDict, total=False):
	            delta: Optional[bool]
	        range: Union[bool, Range_1, None]
	        full: Union[bool, Full_1, None]
	    dynamicRegistration: Optional[bool]
	    requests: Requests_0
	    tokenTypes: List[str]
	    tokenModifiers: List[str]
	    formats: List['TokenFormat']
	    overlappingTokenSupport: Optional[bool]
	    multilineTokenSupport: Optional[bool]
    """

[fail:interface]


[match:type_alias]
M1: """export type integer = number;"""
M2: """export type DiagnosticSeverity = 1 | 2 | 3 | 4;"""
M3: """export type ResourceOperationKind = 'create' | 'rename' | 'delete';"""
M4: """type MarkedString = string | { language: string; value: string };"""
M6: """export type TextDocumentContentChangeEvent = {
		range: Range;
		rangeLength?: uinteger;
		text: string;
	} | {
		text: string;
	};"""

[ast:type_alias]

[fail:type_alias]


[match:declarations_block]
M1: """{
		readonly webviewOptions?: WebviewPanelOptions;
		readonly supportsMultipleEditorsPerDocument?: boolean;
		}"""
M2: """{ dispose: () => any }"""
M3: """{ canPickMany: true }"""
M4: """{
		get<T>(section: string): T | undefined;
		get<T>(section: string, defaultValue: T): T;
		has(section: string): boolean;
		inspect<T>(section: string): {
			key: string;

			defaultValue?: T;
			globalValue?: T;
			workspaceValue?: T;
			workspaceFolderValue?: T;

			defaultLanguageValue?: T;
			globalLanguageValue?: T;
			workspaceLanguageValue?: T;
			workspaceFolderLanguageValue?: T;

			languageIds?: string[];

		} | undefined;
		update(section: string, value: any, configurationTarget?: ConfigurationTarget | boolean | null, overrideInLanguage?: boolean): Thenable<void>;
		readonly [key: string]: any;
	}"""

[ast:declarations_block]

[fail:declarations_block]


[match:declaration]
M1: """let activeTextEditor: TextEditor | undefined"""
M2: """readonly documentation?: ReadonlyArray<{
			readonly kind: CodeActionKind;
			readonly command: Command;
		}>"""

[ast:declaration]

[fail:declaration]

[py:declaration]
M2: """
	class Documentation_0(TypedDict, total=True):
    	kind: 'CodeActionKind'
        command: 'Command'
    documentation: Optional[List[Documentation_0]]"""


[match:function]
M1: """lineAt(line: number): TextLine"""
M2: """save(): Thenable<boolean>"""
M3: """edit(callback: (editBuilder: TextEditorEdit) => void, options?: { readonly undoStopBefore: boolean; readonly undoStopAfter: boolean }): Thenable<boolean>"""
M4: """function registerTextEditorCommand(command: string, callback: (textEditor: TextEditor, edit: TextEditorEdit, ...args: any[]) => void, thisArg?: any): Disposable"""
M5: """function identity<Type>(arg: Type): Type"""
M6: """function executeCommand<T = unknown>(command: string, ...rest: any[]): Thenable<T>"""
M7: """function registerCustomEditorProvider(viewType: string, provider: CustomTextEditorProvider | CustomReadonlyEditorProvider | CustomEditorProvider, options?: {
		readonly webviewOptions?: WebviewPanelOptions;
		readonly supportsMultipleEditorsPerDocument?: boolean;
		}): Disposable"""
M8: """static from(...disposableLikes: { dispose: () => any }[]): Disposable"""
M9: """function getSession(providerId: string, scopes: readonly string[], options: AuthenticationGetSessionOptions & { forceNewSession: true | { detail: string } }): Thenable<AuthenticationSession>"""
M10: """function getDiagnostics(): [Uri, Diagnostic[]][]"""
M11: """set(entries: ReadonlyArray<[Uri, readonly Diagnostic[] | undefined]>): void"""
M12: """constructor(taskDefinition: TaskDefinition, scope: WorkspaceFolder | TaskScope.Global | TaskScope.Workspace, name: string, source: string, execution?: ProcessExecution | ShellExecution | CustomExecution, problemMatchers?: string | string[])"""

[match:optional]

[ast:optional]

[fail:optional]
